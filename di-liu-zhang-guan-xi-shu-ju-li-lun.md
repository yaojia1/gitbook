# 第六章 关系数据理论

## 6.1 问题的提出

### 一、概念回顾

关系

关系模式

关系数据库

关系数据库的模式

### 二、关系模式的形式化定义

关系模式由五部分组成，即它是一个五元组：

                    R\(U, D, DOM, F\)

R：      关系名

U：       组成该关系的属性名集合

D：       属性组U中属性所来自的域

DOM： 属性向域的映象集合

F：       属性间数据的依赖关系集合

### 三、什么是数据依赖

1.完整性约束的表现形式

* 限定属性取值范围：例如学生成绩必须在0-100之间 
* 定义属性值间的相互关连（主要体现于值的相等与否），这就是数据依赖，它是数据库模式设计的关键

2.数据依赖

* 一个关系内部属性与属性之间的约束关系 
* 现实世界属性间相互联系的抽象 
* 数据内在的性质 
* 语义的体现

3.数据依赖的类型

* 函数依赖（Functional Dependency，简记为FD） 
* 多值依赖（Multivalued Dependency，简记为MVD）
* 其他

### 四、关系模式的简化定义 

~~关系模式R（U, D, DOM, F）~~

由于D、DOM与模式设计关系不大，本章简化为一个三元组：**R（U, F）**

当且仅当U上的一个关系r满足F时，r称为关系模式 R（U, F）的一个关系

### 五、数据依赖对关系模式影响

属性组U上的一组函数依赖F：

    F ＝｛ Sno → Sdept,  Sdept → Mname,  \(Sno, Cno\) → Grade ｝

#### 1.数据冗余太大

浪费大量的存储空间l每一个系主任的姓名重复出现，重复次数与该系所有学生的所有课程成绩出现次数相同。

#### 2. 更新异常（Update Anomalies）

数据冗余 ，更新数据时，维护数据完整性代价大。l某系更换系主任后，必须修改与该系学生有关的每一个元组。

#### 3. 插入异常（Insertion Anomalies）

    如果一个系刚成立，尚无学生，则无法把这个系及其系主任的信息存入数据库。

#### 4. 删除异常（Deletion Anomalies）

     如果某个系的学生全部毕业了， 则在删除该系学生信息的同时，把这个系及其系主任的信息也丢掉了。

#### 结论：

* Student关系模式不是一个好的模式。
* “好”的模式：

  不会发生插入异常、删除异常、更新异常，

  数据冗余应尽可能少

* 原因：由存在于模式中的某些数据依赖引起的
* 解决方法：通过分解关系模式来消除其中不合适的数据依赖

#### 分解关系模式

把这个单一模式分成3个关系模式：

     S（Sno，Sdept，Sno → Sdept）;

     SC（Sno，Cno，Grade，（Sno，Cno） → Grade）;

     DEPT（Sdept，Mname，Sdept→ Mname）

    这三个模式都不会发生插入异常、删除异常的问题，数据的冗余也得到了控制。

## 6.2 规范化

规范化理论正是用来改造关系模式，通过分解关系模式来消除其中不合适的数据依赖，以解决插入异常、删除异常、更新异常和数据冗余问题。

### 6.2.1  函数依赖

#### 函数依赖 

定义6.1   设R\(U\)是一个属性集U上的关系模式，X和Y是U的子集。

    若对于R\(U\)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等， 而在Y上的属性值不等， 则称 “X函数确定Y” 或  “Y函数依赖于X”，记作X→Y。 

#### 平凡函数依赖与非平凡函数依赖 

在关系模式R\(U\)中，对于U的子集X和Y，

如果X→Y，但Y 不属于 X，则称X→Y是非平凡的函数依赖

若X→Y，但Y 属于X,   则称X→Y是平凡的函数依赖

若X→Y，则X称为这个函数依赖的决定属性组，也称为决定因素（Determinant）。 

若X→Y，Y→X，则记作X←→Y。 

若Y不函数依赖于X，则记作X\→Y。

#### 完全函数依赖与部分函数依赖 

> 定义6.2  在R\(U\)中，如果X→Y，并且对于X的任何一个真子集X’，都有X’   不决定 Y, 则称Y对X完全函数依赖，记作
>
>      X F→Y。

> 若X→Y，但Y不完全函数依赖于X，则称Y对X部分函数依赖，记作X  P→ Y。

\(Sno,Cno\)→Grade是完全函数依赖，

\(Sno,Cno\)→Sdept是部分函数依赖

因为Sno →Sdept成立，且Sno是（Sno，Cno）的真子集

#### 传递函数依赖

定义6.3  在R\(U\)中，如果X→Y，\(Y ÍX\) ,Y→X Y→Z， 则称Z对X传递函数依赖。

    记为：X → Z

 注: 如果Y→X， 即X←→Y，则Z直接依赖于X。

### 6.2.2  码

定义6.4  设K为R&lt;U,F&gt;中的属性或属性组合。若K      U，  则K称为R的侯选码（Candidate Key）。

     若候选码多于一个，则选定其中的一个做为主码（Primary Key）。

超键码：包含键码的属性集，每个候选码都是超键码，但是某些超键码不是候选码。

主属性与非主属性  

* 包含在任何一个候选码中的属性 ，称为主属性（Prime attribute）
*  不包含在任何码中的属性称为非主属性（Nonprime attribute）或非码属性（Non-key attribute）

全码 整个属性组是码，称为全码（All-key）

### 6.2.3  范式

范式是符合某一种级别的关系模式的集合v

关系数据库中的关系必须满足一定的要求。满足不同程度要求的为不同范式v

范式的种类： 

* 第一范式\(1NF\)
* 第二范式\(2NF\)
* 第三范式\(3NF\)
* BC范式\(BCNF\)
* 第四范式\(4NF\)   
* 第五范式\(5NF\)

各种范式之间存在联系：

![](.gitbook/assets/image%20%286%29.png)

某一关系模式R为第n范式，可简记为R∈nNF。 

一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化

6.2.4  2NF

6.2.5  3NF

6.2.6  BCNF 6.2.7  规范化小结

## 6.3 数据依赖的公理系统

逻辑蕴含

> 定义6.11  
>
> 对于满足一组函数依赖 F 的关系模式R &lt;U，F&gt;，其任何一个关系r，若函数依赖X→Y都成立, （即r中任意两元组t，s，若t\[X］=s\[X］，则t\[Y］=s\[Y］），则称F逻辑蕴含X →Y

###   Armstrong公理系统

关系模式R 来说有以下的推理规则：

1.  A1.自反律（Reflexivity）：若Y &lt;= X &lt;= U，则X →Y为F所蕴含。 
2. A2.增广律（Augmentation）：若X→Y为F所蕴含，且Z &lt;= U，则XZ→YZ为F所蕴含。 
3. A3.传递律（Transitivity）：若X→Y及Y→Z为F所蕴含，则X→Z为F所蕴含。

### 导出规则

\(1\) 根据A1，A2，A3这三条推理规则可以得到下面三条推理规则：

        § 合并规则：由X→Y，X→Z，有X→YZ。（A2， A3）

        § 伪传递规则：由X→Y，WY→Z，有XW→Z。（A2， A3）

        § 分解规则：由X→Y及 Z&lt;=Y，有X→Z。（A1， A3）

\(2\) 根据合并规则和分解规则，可得引理6.1

   引理6.l  X→A1 A2…Ak成立的充分必要条件是X→Ai成立（i=l，2，…，k）

### 函数依赖闭包

定义6.l2    在关系模式R&lt;U，F&gt;中为F所逻辑蕴含的函数依赖的全体叫作 F的闭包，记为F+。

定义6.13   设F为属性集U上的一组函数依赖，X ÍU， XF+ ={ A\|X→A能由F 根据Armstrong公理导出}，XF+称为属性集X关于函数依赖集F 的闭包

引理6.2 

   设F为属性集U上的一组函数依赖，X，Y &lt;=U，X→Y能

   由F 根据Armstrong公理导出的充分必要条件是Y &lt;=XF+

用途

    将判定X→Y是否能由F根据Armstrong公理导出的问题，转化为求出XF+ 、判定Y是否为XF+的子集的问题

## 6.4 模式的分解

## 6.5 小结

